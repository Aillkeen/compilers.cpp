/**
 * Syntax Specification
 *
 * Contributors:
 *      Jeanderson Barros Canido - http://jeandersonbc.github.io
 */
package compiler.generated;

/**
 * Terminals without associated type
 */
terminal SEMICOLON, NAMESPACE, INLINE, LBRK, RBRK, USING, ASSIGNMENT, LSQRBRK, RSQRBRK, ORASSIGN;
terminal MULTASSIGN, DIVASSIGN, MODASSIGN, PLUSASSIGN, MINUSASSIGN, RSHIFTASSIGN, LSHIFTASSIGN;
terminal ARROW, CONST, VOLATILE, SINGLEAND, DOUBLEAND, NOEXCEPT, THROW, QUESTION, ANDASSIGN;
terminal LPAR, RPAR, ALIGNAS, DOTS, CLASS, STRUCT, UNION, FINAL, EXPLICIT, COMMA, COLON;
terminal XORASSIGN, STARPTR, DANDPTR, SANDPTR, SEPPTR;
    
/**
 * Terminals with types associated
 */
terminal java.lang.String IDENTIFIER;

/**
 * Non terminal symbols
 */
non terminal trailingReturnType, trailingTypeSpecSeq, cvQualifierSeqOpt, cvQualifier, nestedNameSpec;
non terminal typeSpecSeq2, attributeSpecSeqOpt, attributeSpecSeq, paramDeclarationCls, enumListOpt;
non terminal declarationSeqOpt, declarationSeq, declaration, emptyDeclaration, typeId, enumList;
non terminal memberSpecification, classKey, classHead2, classHeadName, baseClauseOpt, enumHead;
non terminal logicalOrExpr, expr, assignmentExpr, assignmentOperator, initializeCls, throwExpr;
non terminal attributeSpec, attributeList, alignmentSpec, dotsOpt, classHead, cvQualifierSeq;
non terminal trailingTypeSpec, classSpec, enumSpec, memberSpecificationOpt, exceptionSpecOpt;
non terminal dynamicExceptionSpec, noExceptSpec, typeIdListOpt, typeIdList, conditionalExpr;
non terminal classVirtSpecSeqOpt, classVirtSpecSeq, baseClause, baseSpec2, refQualifierOpt;
non terminal noPtrAbstractDeclarator, ptrOperator, parametersAndQualifiers, exceptionSpec;
non terminal simpleTypeSpec, elaboratedTypeSpec, typenameSpec, ptrAbstractDeclaratorOpt;
non terminal typeSpecSeq, abstractDeclaratorOpt, abstractDeclarator, typeSpec, constExpr;
non terminal classVirtSpec, baseSpecList, baseSpec, ptrAbstractDeclarator, refQualifier;
non terminal translationUnit, blockDeclaration, originalNamespaceDef, aliasDeclaration;
non terminal namespaceDefinition, namespaceDefinition2, unnamedNamespaceDef, inlineOpt;

/**
 * Precedences
 */
precedence nonassoc DOTS;

/**
 * The Grammar Specification
 *
 * See "README.md" on "http://github.com/jeandersonbc/compilers.cpp"
 * for further information.
 */
start with translationUnit;

translationUnit ::= declarationSeqOpt;

declarationSeqOpt ::= declarationSeq | ;

declarationSeq ::= declaration
    |   declarationSeq declaration
    ;

/**
 * Declaration Types
 */
declaration ::= emptyDeclaration
    |   blockDeclaration
    |   namespaceDefinition
    ;

/**
 * Block Declaration
 */
blockDeclaration ::= aliasDeclaration;

/**
 * Alias Declaration
 */
aliasDeclaration ::= USING IDENTIFIER ASSIGNMENT typeId SEMICOLON;

typeId ::= typeSpecSeq abstractDeclaratorOpt;

abstractDeclaratorOpt ::= abstractDeclarator | ;

abstractDeclarator ::= ptrAbstractDeclarator
    |   noPtrAbstractDeclarator parametersAndQualifiers trailingReturnType
    |   parametersAndQualifiers trailingReturnType
    |   DOTS
    ;

parametersAndQualifiers ::=
    LPAR paramDeclarationCls RPAR attributeSpecSeqOpt cvQualifierSeqOpt refQualifierOpt exceptionSpecOpt
    ;

cvQualifierSeqOpt ::= cvQualifierSeq | ;

exceptionSpecOpt ::= exceptionSpec | ;

exceptionSpec ::= dynamicExceptionSpec | noExceptSpec ;

noExceptSpec ::= NOEXCEPT LPAR constExpr RPAR
    |   NOEXCEPT
    ;

/**
 * Expressions
 */
constExpr ::= conditionalExpr;

/** expr NOT IMPLEMENTED */
conditionalExpr ::= logicalOrExpr
    |   logicalOrExpr QUESTION expr COLON assignmentExpr
    ;

/** logicalOrExpr NOT IMPLEMENTED */
/** initializeCls NOT IMPLEMENTED */
/** throwExpr NOT IMPLEMENTED */
assignmentExpr ::= conditionalExpr
    |   logicalOrExpr assignmentOperator initializeCls
    |   throwExpr
    ;

assignmentOperator ::= ASSIGNMENT
    |   MULTASSIGN
    |   DIVASSIGN
    |   MODASSIGN
    |   PLUSASSIGN
    |   MINUSASSIGN
    |   RSHIFTASSIGN
    |   LSHIFTASSIGN
    |   ANDASSIGN
    |   XORASSIGN
    |   ORASSIGN
    ;

dynamicExceptionSpec ::= THROW LPAR typeIdListOpt RPAR;

typeIdListOpt ::= typeIdList | ;

typeIdList ::= typeId dotsOpt
    |   typeIdList COMMA typeId dotsOpt
    ;

refQualifierOpt ::= refQualifier | ;

refQualifier ::= SINGLEAND | DOUBLEAND;

cvQualifierSeq ::=  cvQualifier
    |   cvQualifier cvQualifierSeq
    ;

cvQualifier ::= CONST | VOLATILE;

trailingReturnType ::= ARROW trailingTypeSpecSeq abstractDeclaratorOpt;

trailingTypeSpecSeq ::= trailingTypeSpec attributeSpecSeqOpt
    |   trailingTypeSpec trailingTypeSpecSeq
    ;

/* noPtrAbstractDeclarator NOT IMPLEMENTED */
ptrAbstractDeclarator ::= noPtrAbstractDeclarator
    |   ptrOperator ptrAbstractDeclaratorOpt
    ;

ptrAbstractDeclaratorOpt ::= ptrAbstractDeclarator | ;

/** nestedNameSpec NOT IMPLEMENTED */
ptrOperator ::= STARPTR attributeSpecSeqOpt cvQualifierSeqOpt
    |   SANDPTR attributeSpecSeqOpt
    |   DANDPTR attributeSpecSeqOpt
    |   SEPPTR nestedNameSpec SANDPTR attributeSpecSeqOpt cvQualifierSeqOpt
    |   nestedNameSpec SANDPTR attributeSpecSeqOpt cvQualifierSeqOpt
    ;

typeSpecSeq ::= typeSpec typeSpecSeq2;
typeSpecSeq2 ::= attributeSpecSeqOpt
    |   typeSpecSeq
    ;

typeSpec ::= trailingTypeSpec
    |   classSpec
    |   enumSpec
    ;

/* enumHead NOT IMPLEMENTED
 * enumList enumListOpt NOT IMPLEMENTED
 */
enumSpec ::= enumHead LBRK enumListOpt RBRK
    |   enumHead LBRK enumList COMMA RBRK
    ;

/* simpleTypeSpec NOT IMPLEMENTED
 * elaboratedTypeSpec NOT IMPLEMENTED
 * typenameSpec NOT IMPLEMENTED
 */
trailingTypeSpec ::= simpleTypeSpec
    |   elaboratedTypeSpec
    |   typenameSpec
    |   cvQualifier
    ;

classSpec ::= classHead LBRK memberSpecificationOpt RBRK;

/* memberSpecification NOT IMPLEMENTED */
memberSpecificationOpt ::= memberSpecification | ;

/* classHeadName NOT IMPLEMENTED */
classHead ::= classKey attributeSpecSeqOpt classHead2;
classHead2 ::= classHeadName classVirtSpecSeqOpt baseClauseOpt
    |   baseClauseOpt
    ;

classKey ::= CLASS | STRUCT | UNION;

classVirtSpecSeqOpt ::= classVirtSpecSeq | ;

classVirtSpecSeq ::= classVirtSpec
    |   classVirtSpecSeq classVirtSpec
    ;

classVirtSpec ::= FINAL | EXPLICIT;

baseClauseOpt ::= baseClause | ;

baseClause ::= COLON baseSpecList;

baseSpecList ::= baseSpec dotsOpt
    |   baseSpecList COMMA baseSpec dotsOpt
    ;

/* baseSpec NOT IMPLEMENTED */
baseSpec ::= attributeSpecSeqOpt baseSpec2;

attributeSpecSeqOpt ::= attributeSpecSeq | ;

attributeSpecSeq ::= attributeSpec
    |   attributeSpecSeq attributeSpec
    ;

/* attributeList NOT IMPLEMENTED */
attributeSpec ::= LSQRBRK LSQRBRK attributeList RSQRBRK RSQRBRK
    |   alignmentSpec
    ;

/* ISSUE #2 - rule "alignment-expression" not defined in the grammar ref */
alignmentSpec ::= ALIGNAS LPAR typeId dotsOpt RPAR;

/**
 * Empty Declaration
 */
emptyDeclaration ::= SEMICOLON;

/**
 * Namespace Definition
 */
namespaceDefinition ::= inlineOpt NAMESPACE namespaceDefinition2;
namespaceDefinition2 ::= unnamedNamespaceDef
    |   originalNamespaceDef
    ;

unnamedNamespaceDef ::= LBRK declarationSeqOpt RBRK;
originalNamespaceDef ::= IDENTIFIER LBRK declarationSeqOpt RBRK;

inlineOpt ::= INLINE | ;
dotsOpt ::= DOTS | ;
