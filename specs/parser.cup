/**
 * Syntax Specification
 *
 * Contributors:
 *      Jeanderson Barros Canido - http://jeandersonbc.github.io
 */
package compiler.generated;

/**
 * Terminals without associated type
 */
terminal SEMICOLON, NAMESPACE, INLINE, LBRK, RBRK, USING, ASSIGNMENT, LSQRBRK, RSQRBRK, ORASSIGN, GTE;
terminal MULTASSIGN, DIVASSIGN, MODASSIGN, PLUSASSIGN, MINUSASSIGN, RSHIFTASSIGN, LSHIFTASSIGN, LTE;
terminal ARROW, CONST, VOLATILE, SINGLEAND, DOUBLEAND, NOEXCEPT, THROW, QUESTION, ANDASSIGN, LT, GT;
terminal LPAR, RPAR, ALIGNAS, DOTS, CLASS, STRUCT, UNION, FINAL, EXPLICIT, COMMA, COLON, NEQOP, LSHIFT;
terminal XORASSIGN, STARPTR, SEPPTR, OROP, SOROP, XOROP, EQOP, RSHIFT;
terminal MINUSOP, PLUSOP;
    
/**
 * Terminals with types associated
 */
terminal java.lang.String IDENTIFIER;

/**
 * Non terminal symbols
 */
non terminal namespaceDefinition, namespaceDefinition2, unnamedNamespaceDef, inlineOpt, additiveExpr;
non terminal trailingReturnType, trailingTypeSpecSeq, cvQualifierSeqOpt, cvQualifier, nestedNameSpec;
non terminal typeSpecSeq2, attributeSpecSeqOpt, attributeSpecSeq, paramDeclarationCls, enumListOpt;
non terminal translationUnit, blockDeclaration, originalNamespaceDef, aliasDeclaration, multExpr;
non terminal inclusiveOrExpr, exclusiveOrExpr, andExpr, equalityExpr, relationalExpr, shiftExpr;
non terminal declarationSeqOpt, declarationSeq, declaration, emptyDeclaration, typeId, enumList;
non terminal memberSpecification, classKey, classHead2, classHeadName, baseClauseOpt, enumHead;
non terminal attributeSpec, attributeList, alignmentSpec, dotsOpt, classHead, cvQualifierSeq;
non terminal trailingTypeSpec, classSpec, enumSpec, memberSpecificationOpt, exceptionSpecOpt;
non terminal dynamicExceptionSpec, noExceptSpec, typeIdListOpt, typeIdList, conditionalExpr;
non terminal classVirtSpecSeqOpt, classVirtSpecSeq, baseClause, baseSpec2, refQualifierOpt;
non terminal logicalOrExpr, expr, assignmentExpr, initializeCls, throwExpr, logicalAndExpr;
non terminal noPtrAbstractDeclarator, ptrOperator, parametersAndQualifiers, exceptionSpec;
non terminal simpleTypeSpec, elaboratedTypeSpec, typenameSpec, ptrAbstractDeclaratorOpt;
non terminal typeSpecSeq, abstractDeclaratorOpt, abstractDeclarator, typeSpec, constExpr;
non terminal classVirtSpec, baseSpecList, baseSpec, ptrAbstractDeclarator, refQualifier;

/**
 * Precedences
 */
precedence nonassoc DOTS;

/**
 * The Grammar Specification
 *
 * See "README.md" on "http://github.com/jeandersonbc/compilers.cpp"
 * for further information.
 */
start with translationUnit;

translationUnit ::= declarationSeqOpt;

declarationSeqOpt ::= declarationSeq | ;

declarationSeq ::= declaration
    |   declarationSeq declaration
    ;

/**
 * Declaration Types
 */
declaration ::= emptyDeclaration
    |   blockDeclaration
    |   namespaceDefinition
    ;

/**
 * Block Declaration
 */
blockDeclaration ::= aliasDeclaration;

/**
 * Alias Declaration
 */
aliasDeclaration ::= USING IDENTIFIER ASSIGNMENT typeId SEMICOLON;

typeId ::= typeSpecSeq abstractDeclaratorOpt;

abstractDeclaratorOpt ::= abstractDeclarator | ;

abstractDeclarator ::= ptrAbstractDeclarator
    |   noPtrAbstractDeclarator parametersAndQualifiers trailingReturnType
    |   parametersAndQualifiers trailingReturnType
    |   DOTS
    ;

parametersAndQualifiers ::=
    LPAR paramDeclarationCls RPAR attributeSpecSeqOpt cvQualifierSeqOpt refQualifierOpt exceptionSpecOpt
    ;

cvQualifierSeqOpt ::= cvQualifierSeq | ;

exceptionSpecOpt ::= exceptionSpec | ;

exceptionSpec ::= dynamicExceptionSpec | noExceptSpec ;

noExceptSpec ::= NOEXCEPT LPAR constExpr RPAR
    |   NOEXCEPT
    ;

/**
 * Expressions
 */
expr ::= assignmentExpr
    |   expr COMMA assignmentExpr
    ;

constExpr ::= conditionalExpr;

conditionalExpr ::= logicalOrExpr
    |   logicalOrExpr QUESTION expr COLON assignmentExpr
    ;

/** initializeCls NOT IMPLEMENTED */
/** throwExpr NOT IMPLEMENTED */
assignmentExpr ::= conditionalExpr
    |   logicalOrExpr ASSIGNMENT initializeCls
    |   logicalOrExpr MULTASSIGN initializeCls
    |   logicalOrExpr DIVASSIGN initializeCls
    |   logicalOrExpr MODASSIGN initializeCls
    |   logicalOrExpr PLUSASSIGN initializeCls
    |   logicalOrExpr MINUSASSIGN initializeCls
    |   logicalOrExpr RSHIFTASSIGN initializeCls
    |   logicalOrExpr LSHIFTASSIGN initializeCls
    |   logicalOrExpr ANDASSIGN initializeCls
    |   logicalOrExpr XORASSIGN initializeCls
    |   logicalOrExpr ORASSIGN initializeCls
    |   throwExpr
    ;

logicalOrExpr ::= logicalAndExpr
    |   logicalOrExpr OROP logicalAndExpr
    ;

logicalAndExpr ::= inclusiveOrExpr 
    |   logicalAndExpr DOUBLEAND inclusiveOrExpr
    ;

inclusiveOrExpr ::= exclusiveOrExpr
    |   inclusiveOrExpr SOROP exclusiveOrExpr
    ;

exclusiveOrExpr ::= andExpr
    | exclusiveOrExpr XOROP andExpr
    ;

andExpr ::= equalityExpr
    | andExpr SINGLEAND equalityExpr
    ;

equalityExpr ::= relationalExpr
    |   equalityExpr EQOP relationalExpr
    |   equalityExpr NEQOP relationalExpr
    ;

relationalExpr ::= shiftExpr
    |   relationalExpr LT shiftExpr
    |   relationalExpr GT shiftExpr
    |   relationalExpr LTE shiftExpr
    |   relationalExpr GTE shiftExpr
    ;

shiftExpr ::= additiveExpr
    |   shiftExpr LSHIFT additiveExpr
    |   shiftExpr RSHIFT additiveExpr
    ;

/** multExpr NOT IMPLEMENTED */
additiveExpr ::= multExpr
    |   additiveExpr PLUSOP multExpr
    |   additiveExpr MINUSOP multExpr
    ;

dynamicExceptionSpec ::= THROW LPAR typeIdListOpt RPAR;

typeIdListOpt ::= typeIdList | ;

typeIdList ::= typeId dotsOpt
    |   typeIdList COMMA typeId dotsOpt
    ;

refQualifierOpt ::= refQualifier | ;

refQualifier ::= SINGLEAND | DOUBLEAND;

cvQualifierSeq ::=  cvQualifier
    |   cvQualifier cvQualifierSeq
    ;

cvQualifier ::= CONST | VOLATILE;

trailingReturnType ::= ARROW trailingTypeSpecSeq abstractDeclaratorOpt;

trailingTypeSpecSeq ::= trailingTypeSpec attributeSpecSeqOpt
    |   trailingTypeSpec trailingTypeSpecSeq
    ;

/* noPtrAbstractDeclarator NOT IMPLEMENTED */
ptrAbstractDeclarator ::= noPtrAbstractDeclarator
    |   ptrOperator ptrAbstractDeclaratorOpt
    ;

ptrAbstractDeclaratorOpt ::= ptrAbstractDeclarator | ;

/** nestedNameSpec NOT IMPLEMENTED */
ptrOperator ::= STARPTR attributeSpecSeqOpt cvQualifierSeqOpt
    |   SINGLEAND attributeSpecSeqOpt
    |   DOUBLEAND attributeSpecSeqOpt
    |   SEPPTR nestedNameSpec SINGLEAND attributeSpecSeqOpt cvQualifierSeqOpt
    |   nestedNameSpec SINGLEAND attributeSpecSeqOpt cvQualifierSeqOpt
    ;

typeSpecSeq ::= typeSpec typeSpecSeq2;
typeSpecSeq2 ::= attributeSpecSeqOpt
    |   typeSpecSeq
    ;

typeSpec ::= trailingTypeSpec
    |   classSpec
    |   enumSpec
    ;

/* enumHead NOT IMPLEMENTED
 * enumList enumListOpt NOT IMPLEMENTED
 */
enumSpec ::= enumHead LBRK enumListOpt RBRK
    |   enumHead LBRK enumList COMMA RBRK
    ;

/* simpleTypeSpec NOT IMPLEMENTED
 * elaboratedTypeSpec NOT IMPLEMENTED
 * typenameSpec NOT IMPLEMENTED
 */
trailingTypeSpec ::= simpleTypeSpec
    |   elaboratedTypeSpec
    |   typenameSpec
    |   cvQualifier
    ;

classSpec ::= classHead LBRK memberSpecificationOpt RBRK;

/* memberSpecification NOT IMPLEMENTED */
memberSpecificationOpt ::= memberSpecification | ;

/* classHeadName NOT IMPLEMENTED */
classHead ::= classKey attributeSpecSeqOpt classHead2;
classHead2 ::= classHeadName classVirtSpecSeqOpt baseClauseOpt
    |   baseClauseOpt
    ;

classKey ::= CLASS | STRUCT | UNION;

classVirtSpecSeqOpt ::= classVirtSpecSeq | ;

classVirtSpecSeq ::= classVirtSpec
    |   classVirtSpecSeq classVirtSpec
    ;

classVirtSpec ::= FINAL | EXPLICIT;

baseClauseOpt ::= baseClause | ;

baseClause ::= COLON baseSpecList;

baseSpecList ::= baseSpec dotsOpt
    |   baseSpecList COMMA baseSpec dotsOpt
    ;

/* baseSpec NOT IMPLEMENTED */
baseSpec ::= attributeSpecSeqOpt baseSpec2;

attributeSpecSeqOpt ::= attributeSpecSeq | ;

attributeSpecSeq ::= attributeSpec
    |   attributeSpecSeq attributeSpec
    ;

/* attributeList NOT IMPLEMENTED */
attributeSpec ::= LSQRBRK LSQRBRK attributeList RSQRBRK RSQRBRK
    |   alignmentSpec
    ;

/* ISSUE #2 - rule "alignment-expression" not defined in the grammar ref */
alignmentSpec ::= ALIGNAS LPAR typeId dotsOpt RPAR;

/**
 * Empty Declaration
 */
emptyDeclaration ::= SEMICOLON;

/**
 * Namespace Definition
 */
namespaceDefinition ::= inlineOpt NAMESPACE namespaceDefinition2;
namespaceDefinition2 ::= unnamedNamespaceDef
    |   originalNamespaceDef
    ;

unnamedNamespaceDef ::= LBRK declarationSeqOpt RBRK;
originalNamespaceDef ::= IDENTIFIER LBRK declarationSeqOpt RBRK;

inlineOpt ::= INLINE | ;
dotsOpt ::= DOTS | ;
