/**
 * Syntax Specification
 *
 * Contributors:
 *      Jeanderson Barros Candido - http://jeandersonbc.github.io
 */
package compiler.generated;

/**
 * Terminals without associated type
 */
terminal SEMICOLON, NAMESPACE, INLINE, LBRK, RBRK, USING, ASSIGNMENT, LSQRBRK, RSQRBRK, ORASSIGN, GTE, EXTERN, ASM;
terminal ARROW, CONST, VOLATILE, SINGLEAND, DOUBLEAND, NOEXCEPT, THROW, QUESTION, ANDASSIGN, LT, GT, STATIC_ASSERT;
terminal MULTASSIGN, DIVASSIGN, MODASSIGN, PLUSASSIGN, MINUSASSIGN, RSHIFTASSIGN, LSHIFTASSIGN, LTE, DOT;
terminal LPAR, RPAR, ALIGNAS, DOTS, CLASS, STRUCT, UNION, FINAL, EXPLICIT, COMMA, COLON, NEQOP, LSHIFT;
terminal XORASSIGN, STAR, SEPPTR, OROP, SOROP, XOROP, EQOP, RSHIFT, DIVOP, MODOP, DOTSTAR, ARROWSTAR;
terminal MINUSOP, PLUSOP, ALIGNOF, AUTOINCRM, AUTODECRM, SIZEOF, LOGNEGATION, BINNEG, TYPEID, TEMPLATE;
terminal DYNAMICCAST, STATICCAST, CONSTCAST, REINTERPRETCAST, THIS, NULLPTR, VIRTUAL, PRIVATE, PUBLIC;
terminal PROTECTED, DECLTYPE, DEFAULT, DELETE, TRY, CATCH;
    
/**
 * Terminals with types associated
 */
terminal java.lang.String IDENTIFIER;
terminal java.lang.Boolean TRUE, FALSE;

/**
 * Non terminal symbols
 */
non terminal assignmentOperator, templateArgList, functionDef, functionBody, declSpecSeqOpt, declarator, exceptionDecl;
non terminal classVirtSpecSeqOpt, classVirtSpecSeq, baseClause, baseSpec2, refQualifierOpt, deleteExpr, ptrDeclarator;
non terminal trailingReturnType, trailingTypeSpecSeq, cvQualifierSeqOpt, cvQualifier, nestedNameSpec, pointerLiteral;
non terminal namespaceDefinition, namespaceDefinition2, unnamedNamespaceDef, inlineOpt, additiveExpr, unqualifiedId;
non terminal typeSpecSeq, abstractDeclaratorOpt, abstractDeclarator, typeSpec, constExpr, unaryExpr, booleanLiteral;
non terminal simpleTypeSpec, elaboratedTypeSpec, typenameSpec, ptrAbstractDeclaratorOpt, castExpr, characterLiteral;
non terminal memberSpecification, classKey, classHead2, classHeadName, baseClauseOpt, enumHead, literal, usingDecl;
non terminal bracedInitList, commaOpt, initializeList, assignmentExprOpt, postfixExpr, unaryOp, idExpr, virtualOpt;
non terminal typeSpecSeq2, attributeSpecSeqOpt, attributeSpecSeq, paramDeclarationCls, enumListOpt, stringLiteral;
non terminal translationUnit, blockDeclaration, originalNamespaceDef, aliasDeclaration, multExpr, integerLiteral;
non terminal logicalOrExpr, expr, assignmentExpr, initializeCls, throwExpr, logicalAndExpr, newExpr, qualifiedId;
non terminal baseTypeSpec, classOrDeclType, className, declTypeSpec, simpleTemplateId, accessSpec, accessSpecOpt;
non terminal trailingTypeSpec, classSpec, enumSpec, memberSpecificationOpt, exceptionSpecOpt, bracedInitListOpt;
non terminal noPtrDeclarator, functionTryBlock, ctorInitializer, handlerSeq, handler, templateDecl, linkageSpec;
non terminal noPtrAbstractDeclarator, ptrOperator, parametersAndQualifiers, exceptionSpec, noexceptExpr, asmDef;
non terminal explicitInst, explicitSpecialization, attributeDecl, templateParamList, templateParam, simpleDecl;
non terminal classVirtSpec, baseSpecList, baseSpec, ptrAbstractDeclarator, refQualifier, pmExpr, lambdaExpr;
non terminal declarationSeqOpt, declarationSeq, declaration, emptyDeclaration, typeId, pseudoDestructorName;
non terminal userDefinedLiteral, floatingLiteral, lambdaIntroducer, lambdaDeclaratorOpt, compoundStatement;
non terminal inclusiveOrExpr, exclusiveOrExpr, andExpr, equalityExpr, relationalExpr, shiftExpr, enumList;
non terminal attributeSpec, attributeList, alignmentSpec, dotsOpt, classHead, cvQualifierSeq, exprListOpt;
non terminal dynamicExceptionSpec, noExceptSpec, typeIdListOpt, typeIdList, conditionalExpr, primaryExpr, attributeOpt;
non terminal namespaceAliasDef, usingDirective, staticAssertDecl, opaqueEnumDecl, initDeclaratorListOpt, balancedToken;
non terminal attributeToken, attributeArgClsOpt, attributeArgCls, attributeScopedToken, balancedTokenSeq, attribute;

/**
 * Precedences
 */
precedence nonassoc DOTS, LPAR;

/**
 * The Grammar Specification
 *
 * See "README.md" on "http://github.com/jeandersonbc/compilers.cpp"
 * for further information.
 */
start with translationUnit;

translationUnit ::= declarationSeqOpt;

declarationSeqOpt ::= declarationSeq | ;

declarationSeq ::= declaration
    |   declarationSeq declaration
    ;

/**
 * Declaration Types
 */
declaration ::= emptyDeclaration
    |   blockDeclaration
    |   functionDef
    |   templateDecl 
    |   explicitInst
    |   explicitSpecialization
    |   linkageSpec
    |   namespaceDefinition
    |   attributeDecl
    ;

/**
 * Attribute Declaration
 */
attributeDecl ::= attributeSpecSeq SEMICOLON;

/**
 * Linkage Specification
 */
linkageSpec ::= EXTERN stringLiteral LBRK declSpecSeqOpt RBRK
    |   EXTERN stringLiteral declaration
    ;

/**
 * Explict Instantiation
 */
explicitInst ::= EXTERN TEMPLATE declaration
    |   TEMPLATE declaration
    ;

/**
 * Explict Specialization
 */
explicitSpecialization ::= TEMPLATE LT GT declaration;

/**
 * Template declaration
 */
templateDecl ::= TEMPLATE LT templateParamList GT declaration;

/* templateParam NOT IMPLEMENTED */ 
templateParamList ::= templateParam
    |   templateParamList COMMA templateParam
    ;

/**
 * Function Definition
 */
/* declSpecSeqOpt NOT IMPLEMENTED */
functionDef ::= attributeSpecSeqOpt declSpecSeqOpt declarator functionBody
    |   attributeSpecSeqOpt declSpecSeqOpt declarator ASSIGNMENT DEFAULT SEMICOLON
    |   attributeSpecSeqOpt declSpecSeqOpt declarator ASSIGNMENT DELETE SEMICOLON
    ;


/* Original rule causing "Never reduced" Warning */
/* ctorInitializer NOT IMPLEMENTED */
functionBody ::= ctorInitializer compoundStatement
    |   compoundStatement
    |   functionTryBlock
    ;

functionTryBlock ::= TRY ctorInitializer compoundStatement handlerSeq
    |   TRY compoundStatement handlerSeq
    ;

handlerSeq ::= handler
    |   handler handlerSeq
    ;

handler ::= CATCH LPAR exceptionDecl RPAR compoundStatement;

exceptionDecl ::= attributeSpecSeqOpt typeSpecSeq declarator
    |   attributeSpecSeqOpt typeSpecSeq abstractDeclaratorOpt
    ;

/* noPtrDeclarator NOT IMPLEMENTED */
declarator ::= ptrDeclarator
    |   noPtrDeclarator parametersAndQualifiers trailingReturnType
    ;

ptrDeclarator ::= noPtrDeclarator
    |   ptrOperator ptrDeclarator
    ;

/**
 * Block Declaration
 */
/* namespaceAliasDef NOT IMPLEMENTED */
/* usingDecl NOT IMPLEMENTED */
/* usingDirective NOT IMPLEMENTED */
/* opaqueEnumDecl NOT IMPLEMENTED */
blockDeclaration ::= simpleDecl
    |   asmDef
    |   namespaceAliasDef
    |   usingDecl
    |   usingDirective
    |   staticAssertDecl
    |   aliasDeclaration
    |   opaqueEnumDecl
    ;

staticAssertDecl ::= STATIC_ASSERT LPAR constExpr COMMA stringLiteral RPAR SEMICOLON;

asmDef ::= ASM LPAR stringLiteral RPAR SEMICOLON;

/** initDeclaratorListOpt NOT IMPLEMENTED */
simpleDecl ::= attributeSpecSeqOpt declSpecSeqOpt initDeclaratorListOpt SEMICOLON;

aliasDeclaration ::= USING IDENTIFIER ASSIGNMENT typeId SEMICOLON;

typeId ::= typeSpecSeq abstractDeclaratorOpt;

abstractDeclaratorOpt ::= abstractDeclarator | ;

abstractDeclarator ::= ptrAbstractDeclarator
    |   noPtrAbstractDeclarator parametersAndQualifiers trailingReturnType
    |   parametersAndQualifiers trailingReturnType
    |   DOTS
    ;

parametersAndQualifiers ::=
    LPAR paramDeclarationCls RPAR attributeSpecSeqOpt cvQualifierSeqOpt refQualifierOpt exceptionSpecOpt
    ;

cvQualifierSeqOpt ::= cvQualifierSeq | ;

exceptionSpecOpt ::= exceptionSpec | ;

exceptionSpec ::= dynamicExceptionSpec | noExceptSpec ;

noExceptSpec ::= NOEXCEPT LPAR constExpr RPAR
    |   NOEXCEPT
    ;

/**
 * Expressions
 */
expr ::= assignmentExpr
    |   expr COMMA assignmentExpr
    ;

constExpr ::= conditionalExpr;

conditionalExpr ::= logicalOrExpr
    |   logicalOrExpr QUESTION expr COLON assignmentExpr
    ;

assignmentExprOpt ::= assignmentExpr | ;

assignmentExpr ::= conditionalExpr
    |   logicalOrExpr assignmentOperator initializeCls
    |   throwExpr
    ;

assignmentOperator ::= ASSIGNMENT
    |   MULTASSIGN 
    |   DIVASSIGN 
    |   MODASSIGN 
    |   PLUSASSIGN 
    |   MINUSASSIGN 
    |   RSHIFTASSIGN 
    |   LSHIFTASSIGN 
    |   ANDASSIGN 
    |   XORASSIGN 
    |   ORASSIGN 
    ;

throwExpr ::= THROW assignmentExprOpt;

initializeCls ::= assignmentExpr
    |   bracedInitList
    ;

bracedInitList ::= LBRK initializeList commaOpt RBRK
    |   LBRK RBRK
    ;

initializeList ::= initializeCls dotsOpt
    | initializeList COMMA initializeCls dotsOpt
    ;

commaOpt ::= COMMA | ;

logicalOrExpr ::= logicalAndExpr
    |   logicalOrExpr OROP logicalAndExpr
    ;

logicalAndExpr ::= inclusiveOrExpr 
    |   logicalAndExpr DOUBLEAND inclusiveOrExpr
    ;

inclusiveOrExpr ::= exclusiveOrExpr
    |   inclusiveOrExpr SOROP exclusiveOrExpr
    ;

exclusiveOrExpr ::= andExpr
    | exclusiveOrExpr XOROP andExpr
    ;

andExpr ::= equalityExpr
    | andExpr SINGLEAND equalityExpr
    ;

equalityExpr ::= relationalExpr
    |   equalityExpr EQOP relationalExpr
    |   equalityExpr NEQOP relationalExpr
    ;

relationalExpr ::= shiftExpr
    |   relationalExpr LT shiftExpr
    |   relationalExpr GT shiftExpr
    |   relationalExpr LTE shiftExpr
    |   relationalExpr GTE shiftExpr
    ;

shiftExpr ::= additiveExpr
    |   shiftExpr LSHIFT additiveExpr
    |   shiftExpr RSHIFT additiveExpr
    ;

additiveExpr ::= multExpr
    |   additiveExpr PLUSOP multExpr
    |   additiveExpr MINUSOP multExpr
    ;

multExpr ::= pmExpr
    |   multExpr STAR pmExpr
    |   multExpr DIVOP pmExpr
    |   multExpr MODOP pmExpr
    ;

pmExpr ::= castExpr
    |   pmExpr DOTSTAR castExpr
    |   pmExpr ARROWSTAR castExpr
    ;

castExpr ::= unaryExpr
    |   LPAR typeId RPAR castExpr
    ;

/* noexceptExpr NOT IMPLEMENTED */
/* newExpr NOT IMPLEMENTED */
/* deleteExpr NOT IMPLEMENTED */
unaryExpr ::= postfixExpr
    |   AUTOINCRM castExpr
    |   AUTODECRM castExpr
    |   unaryOp castExpr
    |   SIZEOF unaryExpr
    |   SIZEOF LPAR typeId RPAR
    |   SIZEOF DOTS LPAR IDENTIFIER RPAR
    |   ALIGNOF LPAR typeId RPAR
    |   noexceptExpr
    |   newExpr
    |   deleteExpr
    ;

unaryOp ::= STAR
    |   SINGLEAND
    |   PLUSOP
    |   MINUSOP
    |   LOGNEGATION
    |   BINNEG
    ;

/* pseudoDestructorName NOT IMPLEMENTED */
postfixExpr ::= primaryExpr
    |   postfixExpr LSQRBRK expr RSQRBRK
    |   postfixExpr LSQRBRK bracedInitListOpt RSQRBRK
    |   postfixExpr LPAR exprListOpt RPAR
    |   simpleTypeSpec LPAR exprListOpt RPAR
    |   typenameSpec LPAR exprListOpt RPAR
    |   simpleTypeSpec bracedInitList
    |   typenameSpec bracedInitList
    |   postfixExpr DOT TEMPLATE idExpr
    |   postfixExpr DOT idExpr
    |   postfixExpr ARROW TEMPLATE idExpr
    |   postfixExpr ARROW idExpr
    |   postfixExpr DOT pseudoDestructorName
    |   postfixExpr ARROW pseudoDestructorName
    |   postfixExpr AUTOINCRM
    |   postfixExpr AUTODECRM
    |   DYNAMICCAST LT typeId GT LPAR expr RPAR
    |   STATICCAST LT typeId GT LPAR expr RPAR
    |   REINTERPRETCAST LT typeId GT LPAR expr RPAR
    |   CONSTCAST LT typeId GT LPAR expr RPAR
    |   TYPEID LPAR expr RPAR
    |   TYPEID LPAR typeId RPAR
    ;

/* unqualifiedId NOT IMPLEMENTED */
/* qualifiedId NOT IMPLEMENTED */
idExpr ::= unqualifiedId
    |   qualifiedId
    ;

primaryExpr ::= literal
    |   THIS
    |   LPAR expr RPAR
    |   idExpr
    |   lambdaExpr
    ;

/* lambdaIntroducer NOT IMPLEMENTED */
/* lambdaDeclaratorOpt NOT IMPLEMENTED */
/* compoundStatement NOT IMPLEMENTED */
lambdaExpr ::= lambdaIntroducer lambdaDeclaratorOpt compoundStatement;

/**
 * Literals
 */
/* integerLiteral NOT IMPLEMENTED */
/* characterLiteral NOT IMPLEMENTED */
/* floatingLiteral NOT IMPLEMENTED */
/* stringLiteral NOT IMPLEMENTED */
/* userDefinedLiteral NOT IMPLEMENTED */
literal ::= integerLiteral
    |   characterLiteral
    |   floatingLiteral
    |   stringLiteral
    |   booleanLiteral
    |   pointerLiteral
    |   userDefinedLiteral
    ;

booleanLiteral ::= TRUE | FALSE;

pointerLiteral ::= NULLPTR;

bracedInitListOpt ::= bracedInitList | ;

exprListOpt ::= initializeList | ;

dynamicExceptionSpec ::= THROW LPAR typeIdListOpt RPAR;

typeIdListOpt ::= typeIdList | ;

typeIdList ::= typeId dotsOpt
    |   typeIdList COMMA typeId dotsOpt
    ;

refQualifierOpt ::= refQualifier | ;

refQualifier ::= SINGLEAND | DOUBLEAND;

cvQualifierSeq ::=  cvQualifier
    |   cvQualifier cvQualifierSeq
    ;

cvQualifier ::= CONST | VOLATILE;

trailingReturnType ::= ARROW trailingTypeSpecSeq abstractDeclaratorOpt;

trailingTypeSpecSeq ::= trailingTypeSpec attributeSpecSeqOpt
    |   trailingTypeSpec trailingTypeSpecSeq
    ;

/* noPtrAbstractDeclarator NOT IMPLEMENTED */
ptrAbstractDeclarator ::= noPtrAbstractDeclarator
    |   ptrOperator ptrAbstractDeclaratorOpt
    ;

ptrAbstractDeclaratorOpt ::= ptrAbstractDeclarator | ;

/** nestedNameSpec NOT IMPLEMENTED */
ptrOperator ::= STAR attributeSpecSeqOpt cvQualifierSeqOpt
    |   SINGLEAND attributeSpecSeqOpt
    |   DOUBLEAND attributeSpecSeqOpt
    |   SEPPTR nestedNameSpec SINGLEAND attributeSpecSeqOpt cvQualifierSeqOpt
    |   nestedNameSpec SINGLEAND attributeSpecSeqOpt cvQualifierSeqOpt
    ;

typeSpecSeq ::= typeSpec typeSpecSeq2;
typeSpecSeq2 ::= attributeSpecSeqOpt
    |   typeSpecSeq
    ;

typeSpec ::= trailingTypeSpec
    |   classSpec
    |   enumSpec
    ;

/* enumHead NOT IMPLEMENTED
 * enumList enumListOpt NOT IMPLEMENTED
 */
enumSpec ::= enumHead LBRK enumListOpt RBRK
    |   enumHead LBRK enumList COMMA RBRK
    ;

/* simpleTypeSpec NOT IMPLEMENTED
 * elaboratedTypeSpec NOT IMPLEMENTED
 * typenameSpec NOT IMPLEMENTED
 */
trailingTypeSpec ::= simpleTypeSpec
    |   elaboratedTypeSpec
    |   typenameSpec
    |   cvQualifier
    ;

classSpec ::= classHead LBRK memberSpecificationOpt RBRK;

/* memberSpecification NOT IMPLEMENTED */
memberSpecificationOpt ::= memberSpecification | ;

/* classHeadName NOT IMPLEMENTED */
classHead ::= classKey attributeSpecSeqOpt classHead2;
classHead2 ::= classHeadName classVirtSpecSeqOpt baseClauseOpt
    |   baseClauseOpt
    ;

classKey ::= CLASS | STRUCT | UNION;

classVirtSpecSeqOpt ::= classVirtSpecSeq | ;

classVirtSpecSeq ::= classVirtSpec
    |   classVirtSpecSeq classVirtSpec
    ;

classVirtSpec ::= FINAL | EXPLICIT;

baseClauseOpt ::= baseClause | ;

baseClause ::= COLON baseSpecList;

baseSpecList ::= baseSpec dotsOpt
    |   baseSpecList COMMA baseSpec dotsOpt
    ;

baseSpec ::= attributeSpecSeqOpt baseSpec2;
baseSpec2 ::= baseTypeSpec
    |   VIRTUAL accessSpecOpt baseTypeSpec
    |   accessSpec virtualOpt baseTypeSpec
    ;

virtualOpt ::= VIRTUAL | ;

accessSpecOpt ::= accessSpec | ;

accessSpec ::= PUBLIC
    |   PROTECTED
    |   PRIVATE
    ;

baseTypeSpec ::= classOrDeclType;

classOrDeclType ::= COLON COLON nestedNameSpec className
    |   nestedNameSpec className
    |   COLON COLON className
    |   className
    |   declTypeSpec
    ;

className ::= IDENTIFIER
    |   simpleTemplateId
    ;

/* templateArgList NOT IMPLEMENTED */
simpleTemplateId ::= IDENTIFIER LT templateArgList GT
    |   IDENTIFIER LT GT
    ;

declTypeSpec ::= DECLTYPE LPAR expr RPAR;

attributeSpecSeqOpt ::= attributeSpecSeq | ;

attributeSpecSeq ::= attributeSpec
    |   attributeSpecSeq attributeSpec
    ;

attributeSpec ::= LSQRBRK LSQRBRK attributeList RSQRBRK RSQRBRK
    |   alignmentSpec
    ;

attributeList ::= attribute DOTS
    |   attributeList COMMA attribute DOTS
    |   attributeOpt
    |   attributeList COMMA attributeOpt
    ;

attributeOpt ::= attribute | ;

attribute ::= attributeToken attributeArgClsOpt;

attributeArgClsOpt ::= attributeArgCls | ;

attributeToken ::= IDENTIFIER
    |   attributeScopedToken
    ;

attributeScopedToken ::= IDENTIFIER COLON COLON IDENTIFIER;

attributeArgCls ::= LPAR balancedTokenSeq RPAR;

/* balancedToken NOT IMPLEMENTED */
balancedTokenSeq ::= balancedToken
    |   balancedTokenSeq balancedToken
    ;


/* ISSUE #2 - rule "alignment-expression" not defined in the grammar ref */
alignmentSpec ::= ALIGNAS LPAR typeId dotsOpt RPAR;

/**
 * Empty Declaration
 */
emptyDeclaration ::= SEMICOLON;

/**
 * Namespace Definition
 */
namespaceDefinition ::= inlineOpt NAMESPACE namespaceDefinition2;
namespaceDefinition2 ::= unnamedNamespaceDef
    |   originalNamespaceDef
    ;

unnamedNamespaceDef ::= LBRK declarationSeqOpt RBRK;
originalNamespaceDef ::= IDENTIFIER LBRK declarationSeqOpt RBRK;

inlineOpt ::= INLINE | ;
dotsOpt ::= DOTS | ;
