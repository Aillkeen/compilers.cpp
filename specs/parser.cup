/**
 * Syntax Specification
 *
 * Contributors:
 *      Jeanderson Barros Candido - http://jeandersonbc.github.io
 *      Thiago Ferreira Patricio - http://github.com/tferreirap
 */

package compiler.generated;


parser code {:
    
    public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" in line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
   

        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};


/**
 * Terminals without associated type
 */
terminal SEMICOLON, LBRK, RBRK, USING, ASSIGNMENT, LSQRBRK, RSQRBRK, ORASSIGN, GTE, EXTERN, ASM, ARROW, CONST, VOLATILE;
terminal SINGLEAND, DOUBLEAND, NOEXCEPT, THROW, QUESTION, ANDASSIGN, LT, GT, STATIC_ASSERT, MULTASSIGN, DIVASSIGN, MODASSIGN;
terminal PLUSASSIGN, MINUSASSIGN, RSHIFTASSIGN, LSHIFTASSIGN, LTE, DOT, TYPENAME, LPAR, RPAR, ALIGNAS, DOTS, CLASS, STRUCT;
terminal UNION, FINAL, EXPLICIT, COMMA, COLON, NEQOP, LSHIFT, CONSTEXPR, XORASSIGN, STAR, SEPPTR, OROP, SOROP, XOROP, EQOP;
terminal RSHIFT, DIVOP, MODOP, DOTSTAR, ARROWSTAR, FRIEND, MINUSOP, PLUSOP, ALIGNOF, AUTOINCRM, AUTODECRM, SIZEOF, LOGNEGATION;
terminal BINNEG, TYPEID, TEMPLATE, TYPEDEF, DYNAMICCAST, STATICCAST, CONSTCAST, REINTERPRETCAST, THIS, NULLPTR, VIRTUAL, PRIVATE, PUBLIC;
terminal PROTECTED, DECLTYPE, DEFAULT, DELETE, TRY, CATCH, INTEGER, STRING_LITERAL;

terminal AUTO, BREAK, CASE, CHAR, CONTINUE, DO, DOUBLE, ELSE, FLOAT, FOR, GOTO, IF, INT, BOOL,
LONG, REGISTER, RETURN, SHORT, SIGNED, STATIC, SWITCH, UNSIGNED, VOID, WHILE, OPERATOR, NEW ;
    
/**
 * Terminals with types associated  terminal java.lang.String IDENTIFIER;
 */

terminal IDENTIFIER;
terminal java.lang.Boolean TRUE, FALSE;

/**
 * Non terminal symbols
 */
non terminal dynamicExceptionSpec, noExceptSpec, typeIdListOpt, typeIdList, conditionalExpr, primaryExpr, attributeOpt;
non terminal usingDirective, staticAssertDecl, opaqueEnumDecl, initDeclaratorListOpt, balancedToken;
non terminal assignmentOperator, templateArgList, functionDef, functionBody, declSpecSeqOpt, declarator, exceptionDecl;
non terminal inclusiveOrExpr, exclusiveOrExpr, andExpr, equalityExpr, relationalExpr, shiftExpr, enumList, templateArg;
non terminal classVirtSpecSeqOpt, classVirtSpecSeq, baseClause, baseSpec2, refQualifierOpt, deleteExpr, ptrDeclarator;
non terminal userDefinedLiteral, floatingLiteral, lambdaIntroducer, lambdaDeclaratorOpt, compoundStatement, declSpec;
non terminal trailingReturnType, trailingTypeSpecSeq, cvQualifierSeqOpt, cvQualifier, nestedNameSpec, pointerLiteral;
non terminal additiveExpr, unqualifiedId;
non terminal typeSpecSeq, abstractDeclaratorOpt, abstractDeclarator, typeSpec, constExpr, unaryExpr, booleanLiteral;
non terminal simpleTypeSpec, elaboratedTypeSpec, typenameSpec, ptrAbstractDeclaratorOpt, castExpr, characterLiteral;
non terminal attributeToken, attributeArgClsOpt, attributeArgCls, attributeScopedToken, balancedTokenSeq, attribute;
non terminal memberSpecification, classKey, classHead2, classHeadName, baseClauseOpt, enumHead, literal, usingDecl;
non terminal bracedInitList, commaOpt, initializeList, assignmentExprOpt, postfixExpr, unaryOp, idExpr, virtualOpt;
non terminal typeSpecSeq2, attributeSpecSeqOpt, attributeSpecSeq, paramDeclarationCls, enumListOpt, stringLiteral;
non terminal translationUnit, blockDeclaration, aliasDeclaration, multExpr, integerLiteral;
non terminal logicalOrExpr, expr, assignmentExpr, initializeCls, throwExpr, logicalAndExpr, newExpr, qualifiedId;
non terminal baseTypeSpec, classOrDeclType, className, declTypeSpec, simpleTemplateId, accessSpec, accessSpecOpt;
non terminal attributeSpec, attributeList, alignmentSpec, dotsOpt, classHead, cvQualifierSeq, exprListOpt, token;
non terminal trailingTypeSpec, classSpec, enumSpec, memberSpecificationOpt, exceptionSpecOpt, bracedInitListOpt;
non terminal noPtrDeclarator, functionTryBlock, handlerSeq, handler, templateDecl, linkageSpec, memInitializerId;
non terminal noPtrAbstractDeclarator, ptrOperator, parametersAndQualifiers, exceptionSpec, noexceptExpr, asmDef;
non terminal explicitInst, explicitSpecialization, attributeDecl, templateParamList, templateParam, simpleDecl;
non terminal classVirtSpec, baseSpecList, baseSpec, ptrAbstractDeclarator, refQualifier, pmExpr, lambdaExpr;

non terminal declarationSeqOpt, declarationSeq, declaration, emptyDeclaration, typeId, pseudoDestructorName;
non terminal identifierOpt, declSpecSeq, memInitializerList, memInitializer, declaratorId, storageClassSpec;
non terminal functionSpec, sepptrOpt, typeName, nestedNameSpecOpt, enumName, templateArgListOpt;
non terminal typedefName, templateOpt, ctorInitializerOpt, paramDeclarationListOpt, paramDeclarationList, paramDeclaration;
non terminal statementSeqOpt, statementSeq, statement, exprStatement, selectionStatement, iterationStatement;
non terminal jumpStatement, tryBlock, labeledStatement, declStatement, exprOpt, overloadableOperator, operatorFunctionId;
non terminal conversionFunctionId, conversionTypeId, conversionDeclaratorOpt, conversionDeclarator, condition, conditionOpt;
non terminal initDeclaratorList, initDeclarator, initializerOpt, initializer, braceOrEqualInitializer, forInitStatement;
non terminal forStatement, forRangeInitializer, forRangeDeclaration;

non terminal decimal_Literal, integerSuffix;


/**
 * Precedences
 */
precedence nonassoc DOTS, LPAR, LSQRBRK;

/**
 * The Grammar Specification
 *
 * See "README.md" on "http://github.com/jeandersonbc/compilers.cpp"
 * for further information.
 */
start with translationUnit;

translationUnit ::= declarationSeqOpt;

declarationSeqOpt ::= declarationSeq | ;

declarationSeq ::= declaration
    |   declarationSeq declaration
    ;

/**
 * Declaration Types
 */
/* declaration ::= functionDef; */

declaration ::= blockDeclaration
    |   functionDef
    |   templateDecl 
    |   explicitInst
    |   explicitSpecialization
    |   linkageSpec
    |   emptyDeclaration
    |   attributeDecl
    ;


/**
 * Attribute Declaration
 */
attributeDecl ::= attributeSpecSeq SEMICOLON;

/**
 * Linkage Specification
 */
linkageSpec ::= EXTERN stringLiteral LBRK declSpecSeqOpt RBRK
    |   EXTERN stringLiteral declaration
    ;

/**
 * Explict Instantiation
 */
explicitInst ::= EXTERN TEMPLATE declaration
    |   TEMPLATE declaration
    ;

/**
 * Explict Specialization
 */
explicitSpecialization ::= TEMPLATE LT GT declaration;

/**
 * Template declaration
 */
templateDecl ::= TEMPLATE LT templateParamList GT declaration;

templateParamList ::= templateParam
    |   templateParamList COMMA templateParam
    ;

templateParam ::= CLASS DOTS identifierOpt
    |   CLASS identifierOpt
    |   CLASS identifierOpt ASSIGNMENT typeId
    |   TYPENAME DOTS identifierOpt
    |   TYPENAME identifierOpt
    |   TYPENAME identifierOpt ASSIGNMENT typeId
    |   TEMPLATE LT templateParamList GT CLASS DOTS identifierOpt
    |   TEMPLATE LT templateParamList GT CLASS identifierOpt
    |   TEMPLATE LT templateParamList GT CLASS identifierOpt ASSIGNMENT idExpr
    ;

identifierOpt ::= IDENTIFIER | ;

/**
 * Function Definition
 */

 functionDef ::= declSpec declarator functionBody;

declSpecSeqOpt ::= declSpecSeq | ;

declSpecSeq ::= declSpec
    |   declSpec declSpecSeq
    ;

/** declSpec NOT FINISHED */
declSpec ::= storageClassSpec
    |   typeSpec
    |   functionSpec
    |   FRIEND
    |   TYPEDEF
    |   CONSTEXPR
    ;

storageClassSpec ::= AUTO
    | REGISTER
    | STATIC
    | EXTERN
    ;

functionSpec ::= VIRTUAL
    |   EXPLICIT
    ;

typeSpec ::= trailingTypeSpec
    |   classSpec
    |   enumSpec
    ;

typeName ::= className
    |   enumName
    |   typedefName
    |   simpleTemplateId
    ;

enumName ::= IDENTIFIER;

typedefName ::= IDENTIFIER; 

/* INCOMPLETE */
/* typenameSpec ::= TYPENAME COLON COLON nestedNameSpec IDENTIFIER 
    | TYPENAME nestedNameSpec IDENTIFIER; */

trailingTypeSpec ::= simpleTypeSpec
    |   elaboratedTypeSpec
    |   typenameSpec
    |   cvQualifier
    ;

sepptrOpt ::= SEPPTR | ;

nestedNameSpecOpt ::= nestedNameSpec | ;

nestedNameSpec ::= typeName COLON COLON
    | declTypeSpec COLON COLON
    | nestedNameSpec IDENTIFIER COLON COLON
    | nestedNameSpec templateOpt simpleTemplateId COLON COLON
    ;

simpleTypeSpec ::= sepptrOpt nestedNameSpecOpt typeName
    |   sepptrOpt nestedNameSpec TEMPLATE simpleTemplateId
    |   CHAR
    |   BOOL
    |   SHORT
    |   INT
    |   LONG
    |   SIGNED
    |   UNSIGNED
    |   FLOAT
    |   DOUBLE
    |   VOID
    |   AUTO
    |   declTypeSpec
    ;

/* Original rule causing "Never reduced" Warning */
functionBody ::= COLON memInitializerList compoundStatement
    |   compoundStatement
    |   functionTryBlock
    ;

functionTryBlock ::= TRY COLON memInitializerList compoundStatement handlerSeq
    |   TRY compoundStatement handlerSeq
    ;

memInitializerList ::= memInitializer dotsOpt
    |   memInitializer COMMA memInitializerList dotsOpt
    ;

memInitializer ::= memInitializerId LPAR exprListOpt RPAR
    |   memInitializerId bracedInitList
    ;

memInitializerId ::= classOrDeclType
    | IDENTIFIER
    ;

handlerSeq ::= handler
    |   handler handlerSeq
    ;

handler ::= CATCH LPAR exceptionDecl RPAR compoundStatement;

exceptionDecl ::= attributeSpecSeqOpt typeSpecSeq declarator
    |   attributeSpecSeqOpt typeSpecSeq abstractDeclaratorOpt
    ;


declarator ::= ptrDeclarator
    |   noPtrDeclarator parametersAndQualifiers trailingReturnType
    ;

ptrDeclarator ::= noPtrDeclarator
    |   ptrOperator ptrDeclarator
    ;

noPtrDeclarator ::= declaratorId 
    |   noPtrDeclarator parametersAndQualifiers
    |   noPtrDeclarator LSQRBRK constExpr RSQRBRK attributeSpecSeqOpt
    |   noPtrDeclarator LSQRBRK RSQRBRK attributeSpecSeqOpt
    |   LPAR ptrDeclarator RPAR
    ;

declaratorId ::= idExpr
    |   DOTS idExpr
    |   COLON COLON nestedNameSpecOpt className
    |   COLON COLON className
    |   nestedNameSpec className
    |   className
    ;

/**
 * Block Declaration
 */
/* usingDecl NOT IMPLEMENTED */
/* usingDirective NOT IMPLEMENTED */
/* opaqueEnumDecl NOT IMPLEMENTED */
blockDeclaration ::= simpleDecl
    |   asmDef
    |   staticAssertDecl
    |   aliasDeclaration
    ;

staticAssertDecl ::= STATIC_ASSERT LPAR constExpr COMMA stringLiteral RPAR SEMICOLON;

asmDef ::= ASM LPAR stringLiteral RPAR SEMICOLON;

simpleDecl ::= declSpecSeqOpt initDeclaratorListOpt SEMICOLON;

initDeclaratorListOpt ::= initDeclaratorList | ;

initDeclaratorList ::= initDeclarator 
    |   initDeclaratorList COMMA initDeclarator
    ;   

/* os dois dao erro */ 
initDeclarator ::= IDENTIFIER initializerOpt;

initializerOpt ::= initializer | ;

initializer ::= braceOrEqualInitializer
    |   LPAR exprListOpt RPAR
    ;

braceOrEqualInitializer ::= ASSIGNMENT initializeCls
    |   bracedInitList
    ;

aliasDeclaration ::= USING IDENTIFIER ASSIGNMENT typeId SEMICOLON;

typeId ::= typeSpecSeq abstractDeclaratorOpt;

abstractDeclaratorOpt ::= abstractDeclarator | ;

abstractDeclarator ::= ptrAbstractDeclarator
    |   noPtrAbstractDeclarator parametersAndQualifiers trailingReturnType
    |   parametersAndQualifiers trailingReturnType
    |   DOTS
    ;

parametersAndQualifiers ::= LPAR paramDeclarationCls RPAR;

paramDeclarationCls ::= paramDeclarationListOpt dotsOpt
    | paramDeclarationList COMMA DOTS
    ;

paramDeclarationListOpt ::= paramDeclarationList | ;

paramDeclarationList ::= paramDeclaration
    | paramDeclarationList COMMA paramDeclaration
    ;

paramDeclaration ::= declSpecSeq declarator
    |   declSpecSeq declarator ASSIGNMENT initializeCls
    |   declSpecSeq abstractDeclaratorOpt
    |   declSpecSeq abstractDeclaratorOpt ASSIGNMENT initializeCls
    ;

cvQualifierSeqOpt ::= cvQualifierSeq | ;

exceptionSpecOpt ::= exceptionSpec | ;

exceptionSpec ::= dynamicExceptionSpec | noExceptSpec ;

noExceptSpec ::= NOEXCEPT LPAR constExpr RPAR
    |   NOEXCEPT
    ;

/**
 * Expressions
 */
expr ::= assignmentExpr
    |   expr COMMA assignmentExpr
    ;

constExpr ::= conditionalExpr;

conditionalExpr ::= logicalOrExpr
    |   logicalOrExpr QUESTION expr COLON assignmentExpr
    ;

assignmentExprOpt ::= assignmentExpr | ;

assignmentExpr ::= conditionalExpr
    |   logicalOrExpr assignmentOperator initializeCls
    |   throwExpr
    ;

assignmentOperator ::= ASSIGNMENT
    |   MULTASSIGN 
    |   DIVASSIGN 
    |   MODASSIGN 
    |   PLUSASSIGN 
    |   MINUSASSIGN 
    |   RSHIFTASSIGN 
    |   LSHIFTASSIGN 
    |   ANDASSIGN 
    |   XORASSIGN 
    |   ORASSIGN 
    ;

throwExpr ::= THROW assignmentExprOpt;

initializeCls ::= assignmentExpr
    |   bracedInitList
    ;

bracedInitList ::= LBRK initializeList commaOpt RBRK
    |   LBRK RBRK
    ;

initializeList ::= initializeCls dotsOpt
    | initializeList COMMA initializeCls dotsOpt
    ;

commaOpt ::= COMMA | ;

logicalOrExpr ::= logicalAndExpr
    |   logicalOrExpr OROP logicalAndExpr
    ;

logicalAndExpr ::= inclusiveOrExpr 
    |   logicalAndExpr DOUBLEAND inclusiveOrExpr
    ;

inclusiveOrExpr ::= exclusiveOrExpr
    |   inclusiveOrExpr SOROP exclusiveOrExpr
    ;

exclusiveOrExpr ::= andExpr
    | exclusiveOrExpr XOROP andExpr
    ;

andExpr ::= equalityExpr
    | andExpr SINGLEAND equalityExpr
    ;

equalityExpr ::= relationalExpr
    |   equalityExpr EQOP relationalExpr
    |   equalityExpr NEQOP relationalExpr
    ;

relationalExpr ::= shiftExpr
    |   relationalExpr LT shiftExpr
    |   relationalExpr GT shiftExpr
    |   relationalExpr LTE shiftExpr
    |   relationalExpr GTE shiftExpr
    ;

shiftExpr ::= additiveExpr
    |   shiftExpr LSHIFT additiveExpr
    |   shiftExpr RSHIFT additiveExpr
    ;

additiveExpr ::= multExpr
    |   additiveExpr PLUSOP multExpr
    |   additiveExpr MINUSOP multExpr
    ;

multExpr ::= pmExpr
    |   multExpr STAR pmExpr
    |   multExpr DIVOP pmExpr
    |   multExpr MODOP pmExpr
    ;

pmExpr ::= castExpr
    |   pmExpr DOTSTAR castExpr
    |   pmExpr ARROWSTAR castExpr
    ;

castExpr ::= unaryExpr
    |   LPAR typeId RPAR castExpr
    ;

/* noexceptExpr NOT IMPLEMENTED */
/* newExpr NOT IMPLEMENTED */
/* deleteExpr NOT IMPLEMENTED */
unaryExpr ::= postfixExpr
    |   AUTOINCRM castExpr
    |   AUTODECRM castExpr
    |   unaryOp castExpr
    |   SIZEOF unaryExpr
    |   SIZEOF LPAR typeId RPAR
    |   SIZEOF DOTS LPAR IDENTIFIER RPAR
    |   ALIGNOF LPAR typeId RPAR
    |   noexceptExpr
    |   newExpr
    |   deleteExpr
    ;

unaryOp ::= STAR
    |   SINGLEAND
    |   PLUSOP
    |   MINUSOP
    |   LOGNEGATION
    |   BINNEG
    ;

/* pseudoDestructorName NOT IMPLEMENTED */
postfixExpr ::= primaryExpr
    |   postfixExpr LSQRBRK expr RSQRBRK
    |   postfixExpr LSQRBRK bracedInitListOpt RSQRBRK
    |   postfixExpr LPAR exprListOpt RPAR
    |   simpleTypeSpec LPAR exprListOpt RPAR
    |   typenameSpec LPAR exprListOpt RPAR
    |   simpleTypeSpec bracedInitList
    |   typenameSpec bracedInitList
    |   postfixExpr DOT TEMPLATE idExpr
    |   postfixExpr DOT idExpr
    |   postfixExpr ARROW TEMPLATE idExpr
    |   postfixExpr ARROW idExpr
    |   postfixExpr DOT pseudoDestructorName
    |   postfixExpr ARROW pseudoDestructorName
    |   postfixExpr AUTOINCRM
    |   postfixExpr AUTODECRM
    |   DYNAMICCAST LT typeId GT LPAR expr RPAR
    |   STATICCAST LT typeId GT LPAR expr RPAR
    |   REINTERPRETCAST LT typeId GT LPAR expr RPAR
    |   CONSTCAST LT typeId GT LPAR expr RPAR
    |   TYPEID LPAR expr RPAR
    |   TYPEID LPAR typeId RPAR
    ;

/* qualifiedId NOT IMPLEMENTED */
idExpr ::= unqualifiedId
    |   qualifiedId
    ;

unqualifiedId ::= IDENTIFIER
    |   operatorFunctionId
    |   conversionFunctionId
    |   BINNEG className
    ;

operatorFunctionId ::= OPERATOR overloadableOperator
    |   OPERATOR overloadableOperator LT templateArgListOpt GT
    ;

conversionFunctionId ::= OPERATOR conversionTypeId;

conversionTypeId ::= typeSpecSeq conversionDeclaratorOpt;

/* COMMENT FOR NOW */
/*
 * conversionDeclarator ::= ptrOperator conversionDeclaratorOpt;
 * conversionDeclaratorOpt ::= conversionDeclarator | ;
*/


primaryExpr ::= literal
    |   THIS
    |   LPAR expr RPAR
    |   idExpr
    |   lambdaExpr
    ;

/* lambdaIntroducer NOT IMPLEMENTED */
/* lambdaDeclaratorOpt NOT IMPLEMENTED */
lambdaExpr ::= lambdaIntroducer lambdaDeclaratorOpt compoundStatement;

compoundStatement ::= LBRK statementSeqOpt RBRK;


statementSeqOpt ::= statementSeq | ;

statementSeq ::= statement
    | statementSeq statement
    ;

statement ::= labeledStatement
    |   exprStatement
    |   compoundStatement
    |   selectionStatement
    |   iterationStatement
    |   jumpStatement
    |   blockDeclaration
    |   tryBlock
    ;

// ---- 


labeledStatement ::= IDENTIFIER COLON statement
    |   CASE constExpr COLON statement
    |   DEFAULT COLON statement
    ;

exprOpt ::= expr | ;

selectionStatement ::= IF LPAR condition RPAR statement
    |   IF LPAR condition RPAR statement ELSE statement
    |   SWITCH LPAR condition RPAR statement
    ;

condition ::= expr
    |   declSpecSeq declarator ASSIGNMENT initializeCls
    |   declSpecSeq declarator bracedInitList
    ;

conditionOpt ::= condition | ;

iterationStatement ::= WHILE LPAR condition RPAR statement
    |   DO statement WHILE LPAR expr RPAR SEMICOLON 
    |   FOR LPAR forInitStatement conditionOpt SEMICOLON exprOpt RPAR statement
    |   FOR LPAR forRangeDeclaration COLON forRangeInitializer RPAR statement   
    ;

forRangeDeclaration ::= typeSpecSeq declarator;

forRangeInitializer ::= expr bracedInitList;

forInitStatement ::=  exprOpt 
    | simpleDecl 
    ;

jumpStatement ::= BREAK SEMICOLON
    |   CONTINUE SEMICOLON
    |   RETURN exprOpt SEMICOLON
    |   RETURN bracedInitListOpt SEMICOLON
    |   GOTO IDENTIFIER SEMICOLON
    ;

/**
 * Literals
 */
/* integerLiteral NOT IMPLEMENTED */
/* characterLiteral NOT IMPLEMENTED */
/* floatingLiteral NOT IMPLEMENTED */
/* stringLiteral NOT IMPLEMENTED */
/* userDefinedLiteral NOT IMPLEMENTED */
literal ::= integerLiteral
    |   characterLiteral
    |   floatingLiteral
    |   stringLiteral
    |   booleanLiteral
    |   pointerLiteral
    |   userDefinedLiteral
    ;


integerLiteral ::= INTEGER;

booleanLiteral ::= TRUE | FALSE;

pointerLiteral ::= NULLPTR;

stringLiteral ::= STRING_LITERAL;

bracedInitListOpt ::= bracedInitList | ;

exprListOpt ::= initializeList | ;

dynamicExceptionSpec ::= THROW LPAR typeIdListOpt RPAR;

typeIdListOpt ::= typeIdList | ;

typeIdList ::= typeId dotsOpt
    |   typeIdList COMMA typeId dotsOpt
    ;

refQualifierOpt ::= refQualifier | ;

refQualifier ::= SINGLEAND | DOUBLEAND;

cvQualifierSeq ::=  cvQualifier
    |   cvQualifier cvQualifierSeq
    ;

cvQualifier ::= CONST | VOLATILE;

trailingReturnType ::= ARROW trailingTypeSpecSeq abstractDeclaratorOpt;

trailingTypeSpecSeq ::= trailingTypeSpec attributeSpecSeqOpt
    |   trailingTypeSpec trailingTypeSpecSeq
    ;

/* noPtrAbstractDeclarator NOT IMPLEMENTED */
ptrAbstractDeclarator ::= noPtrAbstractDeclarator
    |   ptrOperator ptrAbstractDeclaratorOpt
    ;

ptrAbstractDeclaratorOpt ::= ptrAbstractDeclarator | ;

ptrOperator ::= STAR attributeSpecSeqOpt cvQualifierSeqOpt
    |   SINGLEAND attributeSpecSeqOpt
    |   DOUBLEAND attributeSpecSeqOpt
    |   SEPPTR nestedNameSpec SINGLEAND attributeSpecSeqOpt cvQualifierSeqOpt
    |   nestedNameSpec SINGLEAND attributeSpecSeqOpt cvQualifierSeqOpt
    ;

typeSpecSeq ::= typeSpec typeSpecSeq2;

typeSpecSeq2 ::= typeSpecSeq
    |
    ;

typeSpec ::= trailingTypeSpec
    |   classSpec
    |   enumSpec
    ;

/* enumHead NOT IMPLEMENTED
 * enumList enumListOpt NOT IMPLEMENTED
 */
enumSpec ::= enumHead LBRK enumListOpt RBRK
    |   enumHead LBRK enumList COMMA RBRK
    ;

/* simpleTypeSpec NOT IMPLEMENTED
 * elaboratedTypeSpec NOT IMPLEMENTED
 * typenameSpec NOT IMPLEMENTED
 */
trailingTypeSpec ::= simpleTypeSpec
    |   elaboratedTypeSpec
    |   typenameSpec
    |   cvQualifier
    ;

classSpec ::= classHead LBRK memberSpecificationOpt RBRK;

/* memberSpecification NOT IMPLEMENTED */
memberSpecificationOpt ::= memberSpecification | ;

/* classHeadName NOT IMPLEMENTED */
classHead ::= classKey attributeSpecSeqOpt classHead2;
classHead2 ::= classHeadName classVirtSpecSeqOpt baseClauseOpt
    |   baseClauseOpt
    ;

classKey ::= CLASS | STRUCT | UNION;

classVirtSpecSeqOpt ::= classVirtSpecSeq | ;

classVirtSpecSeq ::= classVirtSpec
    |   classVirtSpecSeq classVirtSpec
    ;

classVirtSpec ::= FINAL | EXPLICIT;

baseClauseOpt ::= baseClause | ;

baseClause ::= COLON baseSpecList;

baseSpecList ::= baseSpec dotsOpt
    |   baseSpecList COMMA baseSpec dotsOpt
    ;

baseSpec ::= attributeSpecSeqOpt baseSpec2;
baseSpec2 ::= baseTypeSpec
    |   VIRTUAL accessSpecOpt baseTypeSpec
    |   accessSpec virtualOpt baseTypeSpec
    ;

virtualOpt ::= VIRTUAL | ;

accessSpecOpt ::= accessSpec | ;

accessSpec ::= PUBLIC
    |   PROTECTED
    |   PRIVATE
    ;

baseTypeSpec ::= classOrDeclType;

classOrDeclType ::= COLON COLON nestedNameSpec className
    |   nestedNameSpec className
    |   COLON COLON className
    |   className
    |   declTypeSpec
    ;

className ::= IDENTIFIER
    |   simpleTemplateId
    ;

simpleTemplateId ::= IDENTIFIER LT templateArgListOpt GT
    |   IDENTIFIER LT GT
    ;

templateArgListOpt ::= templateArgList | ;

templateArgList ::= templateArg DOTS
    |   templateArg
    |   templateArgList COMMA templateArg DOTS
    |   templateArgList COMMA templateArg
    ;

/*
   templateArg NOT IMPLEMENTED completely
   due to Shift/Reduce conflict
*/
templateArg ::= constExpr
    | typeId
    | idExpr
    ;

declTypeSpec ::= DECLTYPE LPAR expr RPAR;

attributeSpecSeqOpt ::= attributeSpecSeq | ;

attributeSpecSeq ::= attributeSpec
    |   attributeSpecSeq attributeSpec
    ;

attributeSpec ::= LSQRBRK LSQRBRK attributeList RSQRBRK RSQRBRK
    |   alignmentSpec 
    ;

attributeList ::= attribute DOTS
    |   attributeList COMMA attribute DOTS
    |   attributeOpt
    |   attributeList COMMA attributeOpt
    ;

attributeOpt ::= attribute | ;

attribute ::= attributeToken attributeArgClsOpt;

attributeArgClsOpt ::= attributeArgCls | ;

attributeToken ::= IDENTIFIER
    |   attributeScopedToken
    ;

attributeScopedToken ::= IDENTIFIER COLON COLON IDENTIFIER;

attributeArgCls ::= LPAR balancedTokenSeq RPAR;

balancedTokenSeq ::= balancedToken
    |   balancedTokenSeq balancedToken
    ;

/* token NOT IMPLEMENTED */
balancedToken ::= LPAR balancedTokenSeq RPAR
    |   LSQRBRK balancedTokenSeq RSQRBRK
    |   LBRK balancedTokenSeq RBRK
    |   token
    ;

/* ISSUE #2 - rule "alignment-expression" not defined in the grammar ref */
alignmentSpec ::= ALIGNAS LPAR typeId dotsOpt RPAR;

/**
 * Empty Declaration
 */
emptyDeclaration ::= SEMICOLON;

dotsOpt ::= DOTS | ;

overloadableOperator ::= NEW;